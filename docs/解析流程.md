1. Tokenizer
2. Parser Block
   1. 调用 `incorporateLine` 处理每行数据
      1. 设置 `container ` 为 Document 节点
      2. 存储当前行字符串数据到 `this`
      3. 检查当前容器的最后一个节点是否处于打开状态，打开则将容器设为当前节点，并调用该节点的 `continue` 方法来检查，
         - 返回 0 则继续检查子节点
         - 返回 1 则退出检查，并且将容器设为父节点
         - 返回 2 则表示该行已经处理完成，需要退出该行，进入下一行
      4. 状态检查和记录
         - 判断该容器节点是否是上一次处理的节点并存储到全局状态 `allClosed`
         - 记录当前容器当全局状态 `lastMatchedContainer`
         - 判断该容器是否接受行并且不是默认的段落 (Paragraph)，如果判断为 “是” 则标记该容器为 `machedLeaf`, 意味着不再需要进一步分解 Block
         - 如果上一步判断为 “否”，则开始进行分解当前容器
            - 如果不是缩进并且当前位置到下一个非空白位置不存在特殊字符（即 Markdown Block 使用到字符）则跳过空白
            - 依次检查 Block Quote、ATX Heading、Fenced Code、HTML、Setext、Thematic Break、List Item、Indented Code
              - 关闭未匹配到的 Blocks
              - 如果匹配则创建节点并添加到 Tree 上
              - 如果匹配并且该节点是容器节点则返回 1，则将退出循环
              - 如果匹配并且该节点是叶子节点则返回 2，则将退出循环
            - 如果所有项均已经检查但都不匹配则跳转到下一个非空白字符重复该流程
      5. 检查是否为 Lazy 段落
         - 所有 Block 均已关闭
         - 当前行不是空白行
         - 当前处理的 Block 是段落（Paragraph）
      6. 如果是 Lazy 段落则调用 `addLine` 方法
      7. 如果不是则首先关闭未匹配的节点，然后检查当前容器块是否接受 Line，
         - 如果接受则添加当前行，然后再检查当前容器块是否为 HTML 并且是否满足结束条件，如果是则关闭它
         - 如果不接受则创建新的段落然后添加到 tree 然后调用 `addLine` 添加当前行
      8. 进入下一行处理
   2. 调用 `finalize` 处理
3. Parser Inline
   1. 调用 `processInlines` 处理非 Block 级数据
4. 结束，返回 AST